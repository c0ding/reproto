package service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import common.v1.Entry;
import io.grpc.BindableService;
import io.grpc.CallOptions;
import io.grpc.Channel;
import io.grpc.MethodDescriptor;
import io.grpc.MethodDescriptor.Marshaller;
import io.grpc.ServerServiceDefinition;
import io.grpc.stub.AbstractStub;
import io.grpc.stub.ClientCalls;
import io.grpc.stub.ServerCalls;
import io.grpc.stub.StreamObserver;
import io.reproto.MapperProvider;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import javax.annotation.Generated;

public interface HttpService {
  public static final MethodDescriptor<Void, Entry> METHOD_GET_SIMPLE = 
    MethodDescriptor.<Void, Entry>newBuilder()
      .setType(MethodDescriptor.MethodType.UNKNOWN)
      .setFullMethodName(MethodDescriptor.generateFullMethodName("service.HttpService", "get_simple"))
      .setRequestMarshaller(new VoidMarshaller())
      .setResponseMarshaller(new JsonMarshaller(new TypeReference<Entry>(){}))
      .build();

  public static final MethodDescriptor<Void, Void> METHOD_POST_SIMPLE = 
    MethodDescriptor.<Void, Void>newBuilder()
      .setType(MethodDescriptor.MethodType.UNKNOWN)
      .setFullMethodName(MethodDescriptor.generateFullMethodName("service.HttpService", "post_simple"))
      .setRequestMarshaller(new VoidMarshaller())
      .setResponseMarshaller(new VoidMarshaller())
      .build();

  public static final MethodDescriptor<Void, Entry> METHOD_GET_ENTRY = 
    MethodDescriptor.<Void, Entry>newBuilder()
      .setType(MethodDescriptor.MethodType.UNKNOWN)
      .setFullMethodName(MethodDescriptor.generateFullMethodName("service.HttpService", "get_entry"))
      .setRequestMarshaller(new VoidMarshaller())
      .setResponseMarshaller(new JsonMarshaller(new TypeReference<Entry>(){}))
      .build();

  public static final MethodDescriptor<Void, State> METHOD_GET_STATE = 
    MethodDescriptor.<Void, State>newBuilder()
      .setType(MethodDescriptor.MethodType.UNKNOWN)
      .setFullMethodName(MethodDescriptor.generateFullMethodName("service.HttpService", "get_state"))
      .setRequestMarshaller(new VoidMarshaller())
      .setResponseMarshaller(new JsonMarshaller(new TypeReference<State>(){}))
      .build();

  public static final MethodDescriptor<Void, Point> METHOD_GET_POINT = 
    MethodDescriptor.<Void, Point>newBuilder()
      .setType(MethodDescriptor.MethodType.UNKNOWN)
      .setFullMethodName(MethodDescriptor.generateFullMethodName("service.HttpService", "get_point"))
      .setRequestMarshaller(new VoidMarshaller())
      .setResponseMarshaller(new JsonMarshaller(new TypeReference<Point>(){}))
      .build();

  public static final MethodDescriptor<Void, Untagged> METHOD_GET_UNTAGGED = 
    MethodDescriptor.<Void, Untagged>newBuilder()
      .setType(MethodDescriptor.MethodType.UNKNOWN)
      .setFullMethodName(MethodDescriptor.generateFullMethodName("service.HttpService", "get_untagged"))
      .setRequestMarshaller(new VoidMarshaller())
      .setResponseMarshaller(new JsonMarshaller(new TypeReference<Untagged>(){}))
      .build();

  @Generated("Generated by reproto")
  static class ClientStub extends AbstractStub<ClientStub> {
    public ClientStub(
      final Channel channel
    ) {
      super(channel);
    }

    public ClientStub(
      final Channel channel,
      final CallOptions callOptions
    ) {
      super(channel, callOptions);
    }

    @Override
    protected ClientStub build(final Channel channel, final CallOptions callOptions) {
      return new ClientStub(channel, callOptions);
    }

    public StreamObserver<Void> getSimple(final StreamObserver<Entry> observer) {
      return ClientCalls.asyncBidiStreamingCall(getChannel().newCall(METHOD_GET_SIMPLE, getCallOptions()), observer);
    }

    public StreamObserver<Void> postSimple(final StreamObserver<Void> observer) {
      return ClientCalls.asyncBidiStreamingCall(getChannel().newCall(METHOD_POST_SIMPLE, getCallOptions()), observer);
    }

    /**
     * <pre>
     * Endpoint to get a really complicated entity called `Entry` for some reason.
     * 
     * The entity has a ton of optional fields.
     * </pre>
     */
    public StreamObserver<Void> getEntry(final StreamObserver<Entry> observer) {
      return ClientCalls.asyncBidiStreamingCall(getChannel().newCall(METHOD_GET_ENTRY, getCallOptions()), observer);
    }

    /**
     * <pre>
     * Endpoint to get the state of the service.
     * </pre>
     */
    public StreamObserver<Void> getState(final StreamObserver<State> observer) {
      return ClientCalls.asyncBidiStreamingCall(getChannel().newCall(METHOD_GET_STATE, getCallOptions()), observer);
    }

    /**
     * <pre>
     * Endpoint to retrieve a single point.
     * </pre>
     */
    public StreamObserver<Void> getPoint(final StreamObserver<Point> observer) {
      return ClientCalls.asyncBidiStreamingCall(getChannel().newCall(METHOD_GET_POINT, getCallOptions()), observer);
    }

    /**
     * <pre>
     * Endpoint to retrieve a single untagged interface.
     * </pre>
     */
    public StreamObserver<Void> getUntagged(final StreamObserver<Untagged> observer) {
      return ClientCalls.asyncBidiStreamingCall(getChannel().newCall(METHOD_GET_UNTAGGED, getCallOptions()), observer);
    }
  }

  @Generated("Generated by reproto")
  abstract static class ServerStub implements BindableService {
    public StreamObserver<Void> getSimple(final StreamObserver<Entry> observer) {
      return ServerCalls.asyncUnimplementedStreamingCall(METHOD_GET_SIMPLE, observer);
    }

    public StreamObserver<Void> postSimple(final StreamObserver<Void> observer) {
      return ServerCalls.asyncUnimplementedStreamingCall(METHOD_POST_SIMPLE, observer);
    }

    /**
     * <pre>
     * Endpoint to get a really complicated entity called `Entry` for some reason.
     * 
     * The entity has a ton of optional fields.
     * </pre>
     */
    public StreamObserver<Void> getEntry(final StreamObserver<Entry> observer) {
      return ServerCalls.asyncUnimplementedStreamingCall(METHOD_GET_ENTRY, observer);
    }

    /**
     * <pre>
     * Endpoint to get the state of the service.
     * </pre>
     */
    public StreamObserver<Void> getState(final StreamObserver<State> observer) {
      return ServerCalls.asyncUnimplementedStreamingCall(METHOD_GET_STATE, observer);
    }

    /**
     * <pre>
     * Endpoint to retrieve a single point.
     * </pre>
     */
    public StreamObserver<Void> getPoint(final StreamObserver<Point> observer) {
      return ServerCalls.asyncUnimplementedStreamingCall(METHOD_GET_POINT, observer);
    }

    /**
     * <pre>
     * Endpoint to retrieve a single untagged interface.
     * </pre>
     */
    public StreamObserver<Void> getUntagged(final StreamObserver<Untagged> observer) {
      return ServerCalls.asyncUnimplementedStreamingCall(METHOD_GET_UNTAGGED, observer);
    }

    @Override
    public ServerServiceDefinition bindService() {
      return ServerServiceDefinition
        .builder("service.HttpService")
        .addMethod(METHOD_GET_SIMPLE, ServerCalls.asyncBidiStreamingCall(this::getSimple))
        .addMethod(METHOD_POST_SIMPLE, ServerCalls.asyncBidiStreamingCall(this::postSimple))
        .addMethod(METHOD_GET_ENTRY, ServerCalls.asyncBidiStreamingCall(this::getEntry))
        .addMethod(METHOD_GET_STATE, ServerCalls.asyncBidiStreamingCall(this::getState))
        .addMethod(METHOD_GET_POINT, ServerCalls.asyncBidiStreamingCall(this::getPoint))
        .addMethod(METHOD_GET_UNTAGGED, ServerCalls.asyncBidiStreamingCall(this::getUntagged))
        .build();
    }
  }

  public static class JsonMarshaller<T> implements MethodDescriptor.Marshaller<T> {
    private final ObjectMapper mapper;
    private final TypeReference<T> type;

    public JsonMarshaller(
      final TypeReference<T> type
    ) {
      this.mapper = MapperProvider.get();
      this.type = type;
    }

    @Override
    public T parse(final InputStream stream) {
      try {
        return this.mapper.readValue(stream, this.type);
      } catch (final Exception e) {
        throw new RuntimeException(e);
      }
    }

    @Override
    public InputStream stream(final T value) {
      final byte[] bytes;
      try {
        bytes = this.mapper.writeValueAsBytes(value);
      } catch (final Exception e) {
        throw new RuntimeException(e);
      }
      return new ByteArrayInputStream(bytes);
    }
  }

  public static class VoidMarshaller implements MethodDescriptor.Marshaller<Void> {
    @Override
    public Void parse(final InputStream stream) {
      return null;
    }

    @Override
    public InputStream stream(final Void value) {
      return new ByteArrayInputStream(new byte[0]);
    }
  }
}
